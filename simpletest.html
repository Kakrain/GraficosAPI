<html>
	<head>
		<title>Simple test.js app</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body oncontextmenu="return false;">
		<script src="three.min.js"></script>
		<script src="dollar.js"></script>
		<script src="jquery-1.11.1.min.js"></script>
		<script src="notify.min.js"></script>
		<script src="controls.js"></script>
		<script src="dollarWrapper.js"></script>
		<script>

			
			var scene = new THREE.Scene();
			
			var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );
			
			var meshes=[];
			var hemiLightIN=true;
			var dirLightIN=true;
			var lightIN=true;
		var renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.shadowMapBias = 0.0039;
			renderer.shadowMapDarkness = 0.5;
			renderer.shadowMapWidth = 1024;
			renderer.shadowMapHeight = 1024;
			document.body.appendChild( renderer.domElement );

			
THREE.ImageUtils.crossOrigin = "anonymous";
texture = THREE.ImageUtils.loadTexture('madera.jpg');
/*texture = THREE.ImageUtils.loadTexture('madera.jpg', {}, function() {
    renderer.render(scene);
});*/
// -disable-web-security sino no cargaba la imagen


         
			var texturePiso = THREE.ImageUtils.loadTexture('chess.gif');
			texturePiso.wrapS = texturePiso.wrapT = THREE.RepeatWrapping;			
			texturePiso.repeat.set( 80, 80 );
			var geometry = new THREE.PlaneBufferGeometry( 1000, 1000, 1, 1 );
			var material  = new THREE.MeshPhongMaterial( { combine: THREE.MixOperation, map:texturePiso, ambient: 0xffffff, specular: 0x050505 } );
	
	var floors=[]
			var floor = new THREE.Mesh( geometry, material );
			floor.material.side = THREE.DoubleSide;
			floor.rotation.x = Math.PI/2;

			floor.receiveShadow = true;
			floors[floors.length]=floor.clone();//xz
			floor.material.transparent=true;
			floor.material.opacity=0.0;
			floor.rotation.x =0;
			floor.material=floor.material.clone();
			floor.material.transparent=true;
			floor.material.wireframe=true;
			floor.material.opacity=0.0;
			floors[floors.length]=floor.clone();//yx
			floor.rotation.y =Math.PI/2;
			floors[floors.length]=floor.clone();//yz

			scene.add( floors[0] );
			scene.add( floors[1] );
			scene.add( floors[2] );



			var dollarwrapper=new DollarWrapper(renderer);
			//dollarwrapper.printGesture=true;


		var controls=new Controls(camera,dollarwrapper,meshes,scene,floors[0]);
material = new THREE.MeshLambertMaterial({map: texture});
			 geometry = new THREE.BoxGeometry( 1.4, 1, 1 );
			var cube = new THREE.Mesh( geometry, material );
			cube.position.set(1,1,1);
			new Thing(cube,scene);
			cube.castShadow=true;
			cube.receiveShadow=true;
			//cube.position.y=0.5;
			//controls.setSelected(cube);
//scene.add(cube);
var things=[];
var thing= new Thing(cube,scene,floors);
things.push(thing);
meshes.push(cube);

			//http://soledadpenades.com/articles/three-js-tutorials/object-picking/
		var axes = buildAxes();
	scene.add( axes );

var hemiLight,dirLight,light;

seHizoLaLuz();
seHizoElSol();
//seHizoElFoco();
//Y vi que era bueno		
			
			


renderer.shadowMapEnabled = true;
renderer.shadowMapSoft = true;

			var render = function () {
			
			controls.render();
				
			
				requestAnimationFrame(render);
  				camera.updateProjectionMatrix();
				renderer.render(scene, camera);
				//renderer.clearDepth();
				
			};

			render();

function Thing(_mesh,_scene,_floors){
	var floors=_floors;
	var meshes=[];
	var scene=_scene;
	var box = new THREE.Box3().setFromObject(_mesh);
	var dx=box.max.x-box.min.x;
	var dy=box.max.y-box.min.y;
	var dz=box.max.z-box.min.z;
	

	var material= new THREE.MeshBasicMaterial( {color:'red', side:THREE.DoubleSide} );
	var xz=new THREE.Mesh( new THREE.PlaneBufferGeometry( dx, dz, 1, 1 ), material );
	xz.position.set(_mesh.position.x,0.01,_mesh.position.z);
	xz.rotation.x=Math.PI/2

	var xy=new THREE.Mesh( new THREE.PlaneBufferGeometry( dx, dy, 1, 1 ), material );
	xy.position.set(_mesh.position.x,_mesh.position.y,0.01);
	
	var yz=new THREE.Mesh( new THREE.PlaneBufferGeometry( dy, dz, 1, 1 ), material );
	yz.position.set(0.01,_mesh.position.y,_mesh.position.z);
	yz.rotation.y=Math.PI/2

meshes[meshes.length]=_mesh;
meshes[meshes.length]=xz;
meshes[meshes.length]=xy;
meshes[meshes.length]=yz;

xy.geometry.width=1000;
xy.material.transparent=true;
xy.material.opacity=0.5;
	var outline = new THREE.Mesh( meshes[0].geometry, new THREE.MeshBasicMaterial( { color: 0x00ff00, side: THREE.BackSide } ) );
	outline.scale.multiplyScalar(1.05);


scene.add(meshes[0]);
var setOutlinePosition=function(){
	outline.position.x = meshes[0].position.x;
	outline.position.y = meshes[0].position.y;
	outline.position.z = meshes[0].position.z;
}
this.moveTo=function(index,raycast){
	if(index!=0){//significa que no es el mesh principal	
		intersects = raycast.intersectObject(floors[index-1]);
			if(intersects.length!=0){
				var p=intersects[0].point;
				meshes[index].position.x=p.x+0.001;
				meshes[index].position.y=p.y+0.001;
				meshes[index].position.z=p.z+0.001;
			}
	}
	switch(index){
		case 0:{
			break;
		}
		case 1:{//xz
			meshes[0].position.x=meshes[index].position.x;
			meshes[0].position.z=meshes[index].position.z;
			setOutlinePosition();
			meshes[2].position.x=meshes[index].position.x;
			meshes[3].position.z=meshes[index].position.z;
			break;
		}
		case 2:{//xy
			meshes[0].position.x=meshes[index].position.x;
			meshes[0].position.y=meshes[index].position.y;
			setOutlinePosition();
			meshes[1].position.x=meshes[index].position.x;
			meshes[3].position.y=meshes[index].position.y;
			break;
		}
		case 3:{//yz
			meshes[0].position.z=meshes[index].position.z;
			meshes[0].position.y=meshes[index].position.y;
			setOutlinePosition();
			meshes[1].position.z=meshes[index].position.z;
			meshes[2].position.y=meshes[index].position.y;
			break;
		}
	}
}
this.getMeshes=function(){
	return meshes;
}
this.isSelected=function(mesh){
	return meshes[0]==mesh;
}
this.select=function(){
	scene.add(meshes[1]);
	scene.add(meshes[2]);
	scene.add(meshes[3]);

	setOutlinePosition();
	scene.add(outline);
}
this.unselect=function(){
	scene.remove(meshes[1]);
	scene.remove(meshes[2]);
	scene.remove(meshes[3]);

	scene.remove(outline);
}
}
function getThing(mesh){
for (var i = things.length - 1; i >= 0; i--) {
	if(things[i].isSelected(mesh)){return things[i];}
};
return null;
}
function buildAxis( src, dst, colorHex, dashed ) {
		var geom = new THREE.Geometry(),
			mat; 

		if(dashed) {
			mat = new THREE.LineDashedMaterial({ linewidth: 1, color: colorHex, dashSize: 5, gapSize: 5 });
		} else {
			mat = new THREE.LineBasicMaterial({ linewidth: 1, color: colorHex });
		}

		geom.vertices.push( src.clone() );
		geom.vertices.push( dst.clone() );

		var axis = new THREE.Line( geom, mat );

		return axis;

	}
function buildAxes() {
		var axes = new THREE.Object3D();

		axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 100, 0, 0 ), 0xFF0000, false ) ); // +X
		axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( -100, 0, 0 ), 0x800000, true) ); // -X
		axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 100, 0 ), 0x00FF00, false ) ); // +Y
		axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, -100, 0 ), 0x008000, true ) ); // -Y
		axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, 100 ), 0x0000FF, false ) ); // +Z
		axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, -100 ), 0x000080, true ) ); // -Z

		return axes;

	}
function seHizoLaLuz(){
	hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.6 );
	hemiLight.color.setHSL( 0.6, 1, 0.6 );
	hemiLight.groundColor.setHSL( 0.095, 1, 0.75 );
	hemiLight.position.set( 0, 500, 0 );
	scene.add( hemiLight );
}
function seHizoElSol(){
dirLight = new THREE.DirectionalLight( 0xffffff, 1 );
dirLight.color.setHSL( 0.1, 1, 0.95 );
dirLight.position.set( -1, 1.75, 1 );
dirLight.position.multiplyScalar( 50 );
scene.add( dirLight );

dirLight.castShadow = true;

dirLight.shadowMapWidth = 2048;
dirLight.shadowMapHeight = 2048;

var d = 50;
dirLight.shadowCameraLeft = -d;
dirLight.shadowCameraRight = d;
dirLight.shadowCameraTop = d;
dirLight.shadowCameraBottom = -d;

dirLight.shadowCameraFar = 3500;
dirLight.shadowBias = -0.0001;
dirLight.shadowDarkness = 0.35;
}

function seHizoElFoco(){
light = new THREE.SpotLight( 0xffffff, 1 );
light.castShadow = true;
light.shadowDarkness = 1;
light.shadowCameraRight     =  10;
light.shadowCameraLeft     = -10;
light.shadowCameraTop      =  10;
light.shadowCameraBottom   = -10;
light.position.y=4;
scene.add(light);
}
function createSphere(x,y,z,color){
var sphere = new THREE.Mesh(new THREE.SphereGeometry(0.1), new THREE.MeshPhongMaterial({color: color}) );
sphere.position.x=x;
sphere.position.y=y;
sphere.position.z=z;
scene.add(sphere);
}
		</script>
	</body>
</html>