<html>
	<head>
		<title>Simple test.js app</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body oncontextmenu="return false;">
		<script src="three.min.js"></script>
		<script src="dollar.js"></script>
		<script src="jquery-1.11.1.min.js"></script>
		<script src="notify.min.js"></script>
		<script src="controls.js"></script>
		<script src="dollarWrapper.js"></script>
		<script>

			
			var scene = new THREE.Scene();
			
			var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );
			
			var meshes=[];
			var hemiLightIN=true;
			var dirLightIN=true;
			var lightIN=true;
		var renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.shadowMapBias = 0.0039;
			renderer.shadowMapDarkness = 0.5;
			renderer.shadowMapWidth = 1024;
			renderer.shadowMapHeight = 1024;
			document.body.appendChild( renderer.domElement );

			
THREE.ImageUtils.crossOrigin = "anonymous";
texture = THREE.ImageUtils.loadTexture('madera.jpg');
/*texture = THREE.ImageUtils.loadTexture('madera.jpg', {}, function() {
    renderer.render(scene);
});*/
// -disable-web-security sino no cargaba la imagen


        var material = new THREE.MeshLambertMaterial({map: texture});
			var geometry = new THREE.BoxGeometry( 1.4, 1, 1 );
			var cube = new THREE.Mesh( geometry, material );
			cube.position.set(1,1,1);
			new Thing(cube,scene);
			cube.castShadow=true;
			cube.receiveShadow=true;
			//cube.position.y=0.5;
			//controls.setSelected(cube);
scene.add(cube);
meshes.push(cube);
			var texturePiso = THREE.ImageUtils.loadTexture('chess.gif');
			texturePiso.wrapS = texturePiso.wrapT = THREE.RepeatWrapping;			
			texturePiso.repeat.set( 80, 80 );
			geometry = new THREE.PlaneBufferGeometry( 1000, 1000, 1, 1 );
			material  = new THREE.MeshPhongMaterial( {combine: THREE.MixOperation, map:texturePiso, ambient: 0xffffff, specular: 0x050505 } );
	
			var floor = new THREE.Mesh( geometry, material );
			floor.material.side = THREE.DoubleSide;
			floor.rotation.x = Math.PI/2;

			floor.receiveShadow = true;
			scene.add( floor );
			//meshes.push(floor);
			var dollarwrapper=new DollarWrapper(renderer);
			//dollarwrapper.printGesture=true;
		var controls=new Controls(camera,dollarwrapper,meshes,scene,floor);


			//http://soledadpenades.com/articles/three-js-tutorials/object-picking/
		var axes = buildAxes();
	scene.add( axes );

var hemiLight,dirLight,light;

seHizoLaLuz();
seHizoElSol();
//seHizoElFoco();
//Y vi que era bueno		
			
			


renderer.shadowMapEnabled = true;
renderer.shadowMapSoft = true;

			var render = function () {
			
			controls.render();
				
			
				requestAnimationFrame(render);
  				camera.updateProjectionMatrix();
				renderer.render(scene, camera);
				//renderer.clearDepth();
				
			};

			render();

function Thing(_mesh,_scene){
	var mesh=_mesh;
	var scene=_scene;
	var box = new THREE.Box3().setFromObject(mesh);
	var dx=box.max.x-box.min.x;
	var dy=box.max.y-box.min.y;
	var dz=box.max.z-box.min.z;
	
	var material= new THREE.MeshBasicMaterial( {color:'red', side:THREE.DoubleSide} );
	var xy=new THREE.Mesh( new THREE.PlaneBufferGeometry( dx, dy, 1, 1 ), material );
	xy.position.set(mesh.position.x,mesh.position.y,0);
	var xz=new THREE.Mesh( new THREE.PlaneBufferGeometry( dx, dz, 1, 1 ), material );
	xz.position.set(mesh.position.x,0,mesh.position.z);
	xz.rotation.x=Math.PI/2
	var yz=new THREE.Mesh( new THREE.PlaneBufferGeometry( dy, dz, 1, 1 ), material );
	yz.position.set(0,mesh.position.y,mesh.position.z);
	yz.rotation.y=Math.PI/2



scene.add(xy);
scene.add(xz);
scene.add(yz);
this.update=function(notupdating){




}


}
function buildAxis( src, dst, colorHex, dashed ) {
		var geom = new THREE.Geometry(),
			mat; 

		if(dashed) {
			mat = new THREE.LineDashedMaterial({ linewidth: 1, color: colorHex, dashSize: 5, gapSize: 5 });
		} else {
			mat = new THREE.LineBasicMaterial({ linewidth: 1, color: colorHex });
		}

		geom.vertices.push( src.clone() );
		geom.vertices.push( dst.clone() );

		var axis = new THREE.Line( geom, mat );

		return axis;

	}
function buildAxes() {
		var axes = new THREE.Object3D();

		axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 100, 0, 0 ), 0xFF0000, false ) ); // +X
		axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( -100, 0, 0 ), 0x800000, true) ); // -X
		axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 100, 0 ), 0x00FF00, false ) ); // +Y
		axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, -100, 0 ), 0x008000, true ) ); // -Y
		axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, 100 ), 0x0000FF, false ) ); // +Z
		axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, -100 ), 0x000080, true ) ); // -Z

		return axes;

	}
function seHizoLaLuz(){
	hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.6 );
	hemiLight.color.setHSL( 0.6, 1, 0.6 );
	hemiLight.groundColor.setHSL( 0.095, 1, 0.75 );
	hemiLight.position.set( 0, 500, 0 );
	scene.add( hemiLight );
}
function seHizoElSol(){
dirLight = new THREE.DirectionalLight( 0xffffff, 1 );
dirLight.color.setHSL( 0.1, 1, 0.95 );
dirLight.position.set( -1, 1.75, 1 );
dirLight.position.multiplyScalar( 50 );
scene.add( dirLight );

dirLight.castShadow = true;

dirLight.shadowMapWidth = 2048;
dirLight.shadowMapHeight = 2048;

var d = 50;
dirLight.shadowCameraLeft = -d;
dirLight.shadowCameraRight = d;
dirLight.shadowCameraTop = d;
dirLight.shadowCameraBottom = -d;

dirLight.shadowCameraFar = 3500;
dirLight.shadowBias = -0.0001;
dirLight.shadowDarkness = 0.35;
}

function seHizoElFoco(){
light = new THREE.SpotLight( 0xffffff, 1 );
light.castShadow = true;
light.shadowDarkness = 1;
light.shadowCameraRight     =  10;
light.shadowCameraLeft     = -10;
light.shadowCameraTop      =  10;
light.shadowCameraBottom   = -10;
light.position.y=4;
scene.add(light);
}
function createSphere(x,y,z,color){
var sphere = new THREE.Mesh(new THREE.SphereGeometry(0.1), new THREE.MeshPhongMaterial({color: color}) );
sphere.position.x=x;
sphere.position.y=y;
sphere.position.z=z;
scene.add(sphere);
}
		</script>
	</body>
</html>